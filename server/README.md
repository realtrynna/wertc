## Project realize
### 1. Circular dependency(순환 참조, 순환 종속성)
- A 클래스에서 B 클래스를 호출하고, B 클래스에서 A 클래스를 호출 => 순환 종속성
- Nest 에서 Forward referencing(전방 참조)을 사용해 해결 가능
- ModuleRef 클래스를 사용해 DI Container 에서 Provider 를 검색

> **_barrel files_**  
> loader, exporter 등 로더 파일을 barrel 파일이라 부른다.  
> Nest에서 barrel 파일을 통해 Module, Provider 클래스를 호출하지 말라고 함  
> barrel 파일과 **_동일한 경로 내_** 에서 파일 import 금지

References
- https://docs.nestjs.com/fundamentals/circular-dependency
- https://github.com/nestjs/nest/issues/1181  

<br>

### 2. 객체의 역할, 책임, 협력
- 객체의 모양을 만드는 건 객체가 참여하는 협력
- 어떤 협력에 참여하는지에 따라 객체에 필요한 행동이 결정됨
- 필요한 행동이 객체의 상태를 결정함
- 객체의 개별적 행동과 상태가 아닌 객체들 간 협력에 집중해야 함  
  

1. **_협력_**  
협력은 **_요청_** 과 **_응답_** 을 통해 협력 관계가 형성된다. 서로 다른 객체는 **_동일한 목적_** 을 달성하기 위해 협력한다.  
요청과 응답은 협력에 참여하는 객체가 수행할 책임을 정의한다.  
  

2. **_책임_**  
객체는 적절한 행동을 할 의무가 있다면 책임을 가진다고 말할 수 있다. 협력관계에 있는 객체는 어떤 요청에 **_적절히 응답_** 해야 하는 책임을 가진다.  
객체의 책임은 객체가 알아야 하는 정보와 수행할 수 있는 행위에 대해 개략적으로 서술한 문장이다.  
책임은 어떠한 정보를 알 수 있고 어떠한 기능을 할 수 있는 가로 분류할 수 있다.  
    > **Doing**  
    > - 객체를 생성하거나 계산을 하는 스스로 동작
    > - 다른 객체의 행동을 시작
    > - 다른 객체의 활동을 제어하고 조절  
    
    > **Knowing**
    > - 개인적인 정보에 관해 알고 있음
    > - 관련된 객체에 관해 알고 있음
    > - 자신이 유도하거나 계산할 수 있는 걸 알고 있음  
    
    > **_책임은 객체 외부에 제공해 줄 수 있는 서비스와 줄 수 있는 정보의 목록이다._**  
    책임 구현의 정의는 객체와 책임을 고려하고 난 후 정의해도 늦지 않는다.  
    성급히 구현 시 변경에 취약하고 다양한 협력에 참여할 수 없는 비 자율적인 객체를 낳는다.  
   
    <br>  
    
    #### 책임 안에서 메시지
    객체가 다른 객체에게 책임을 수행하도록 요청하는 걸 **_메시지 전송_** 이라 한다.  
    두 객체 간의 협력은 메시지를 통해 이루어지며 협력을 요청한 객체를 **_송신자_**, 처리하는 객체를 **_수신자_** 라 한다.  
    중요한 건 책임과 메시지의 수준이 같지 않고 책임은 객체가 협력에 참여하기 위해 수행해야 하는 행위를 상위 수준에서 개략적으로 서술한 걸 의미한다.  
    책임을 결정, 정제 후 변환하면 여러 메시지로 분할된다.  
    
    > 책임이 협력이라는 문맥 속에서 한 객체의 관점에서 뭘 할 수 있는지를 의미했다면  
    메시지는 협력에 참여하는 두 객체 사이의 관계를 강조를 의미한다.  
    
    객체 지향의 설계는 협력에 참여하기 위해 어떤 객체가 어떤 책임을 수행하고 어떤 객체로부터 메시지를 수신할 건지 결정하는 단계로부터 시작한다.  
    어쩐 클래스가 필요하고 메서드를 포함해야 하는지 결정하는 건 책임과 메시지에 대한 대략적인 윤곽을 잡은 후 시작해도 늦지 않는다.  

<br>

3. **역할**  
객체가 수행하는 책임의 집합은 객체가 협력 안에서 수행하는 **_역할을 암시_** 한다.  
동일한 역할을 수행할 수 있다는 건 협력 내에서 동일한 책임을 수행할 수 있다는 걸 의미한다.  
역할의 개념을 사용하면 협럭을 추상화해 **_인지 과부하_** 를 줄일 수 있고 다양한 객체들이 협력에 참여할 수 있으므로 재사용성이 높아진다.    
역할을 통해 **_재사용_** 가능하고 유용한 객체지향 설계를 할 수 있다.  

    > 역할을 대체할 수 있는 객체는 메시지를 이해할 수 있는 객체로 한정된다.  

    #### 협력안에서 추상화
    협력 안에 여러 종류의 객체가 참여할 수 있게 함으로써 **_추상화_** 할 수 있다.  
    역할을 이용하면 추상화를 통해 협력을 단순화할 수 있다.  

    #### 대체 가능성
    역할은 협력 안에서 구체적인 객체로 대체될 수 있는 추상적인 협력자이면 역할은 다른 객체에 의해 대체 가능하다.  
    역할의 대체 가능성은 행위 호환성을 의미하고 행위 호환성은 동일한 책임의 수행을 의미한다.  
  
    #### 협력에서 일어나는 흔한 오류
   - 데이터를 저장하기 위해 객체가 존재한다는 선입견  
       객체는 행위를 수행하기 위한 재료
   - 객체지향이 클래스와 클래스 간의 관계를 표현하는 시스템의 정적인 측면에 중점을 둔다는 선입견  
     클래스를 어떻게 구현할 건지가 아니라 객체가 협력안에서 어떤 책임과 역할을 수행할 건지를 결정  
  
    #### 협력을 생각하지 않은 체 객체 설계
    데이터나 클래스를 중심으로 애플리케이션을 설계하는 이유는 협력이라는 문맥을 고려하지 않고 각 객체를 독립적으로 바라므로 생긴다.  
    하지만 협력이라는 문맥에서 제거한 객체만으로 설계하기에는 어떤 데이터가 필요하고 어떤 클래스로 구현하는지 고민하는 데 도움이 되지 않는다.  
  
    #### 협력을 따라 흐르는 객체의 책임
   - 견고하고 깔끔한 협력을 설계  
   설계에 참여하는 객체들이 주고받을 요청과 응답의 흐름을 결정
   - 요청과 응답의 흐름을 이용해 겍체에게 책임을 할당  
   요청과 응답의 흐름은 객체가 협력에 참여하기 위해 수행될 책임이 됨  
   - 책임은 객체가 외부에 제공하게 될 행동이 됨  
   - 행동 결정 후 행동을 수행하는 데 필요한 데이터를 생각
    - 객체가 협력에 참여하기 위해 필요한 데이터와 행동이 어느 정도 결정된 후 클래스의 구현 방법을 결정  

    #### 객체지향 설계 기법
    객체지향 설계란 기능을 구현하기 위한 협력 관계를 고안하고 협력에 필요한 역할과 책임을 식별해 이를 수행할 수 있는 적절한 객체를 식별해 나가는 과정이다.  
      
    ##### 책임 주도 설계
    협력에 필요한 책임들을 식별하고 적합한 객체에게 책임을 할당하는 방식으로 애플리케이션을 설계한다.  
   - 시스템이 사용자에게 제공해야 하는 기능인 시스템 **_책임 파악_**
   - 시스템 책임을 **_더 작은 책임_** 으로 분할
   - 분활된 책임을 수행할 수 있는 적절한 객체 도는 역할을 찾아 책임을 **_할당_**
   - 객체가 책임을 수행하는 중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 파악
   - 해당 객체 도는 역할에게 책임을 할당함으로써 두 객체는 **_협력 관계 성립_**  

    > 시스템의 책임을 객체의 책임으로 변환
    > 각 객체가 수행하는 중 필요한 정보나 서비스를 제공해 줄 협력자를 찾음
    > 해당 협력자에게 책임을 할당하는 순차적인 방식으로 객체들의 협력 공동체 구축

<br>

### 3. 요청 생명 주기
Nest 에서 사용되는 **Guard**, **Interceptor**, **Pipe**, **Filter** 는 NodeJS 에서 말하는 Middleware 에 속한다.  
> **Middleware 와 Interceptor 의 차이**  
> Middleware 는 파라미터로 **request**, **response**, **next** 3가지를 받는데 request 와 response 는 HTTP 위에서 동작하도록 설계되어 있다.  
> 그러므로 **_HTTP 통신_** 이 아니면 사용할 수 없다.  
> 반면 Interceptor 는 **_execution context_** 라는 Helper class 를 받아 처리하므로 WebSocket, GQL, RPC 위에서 동작할 수 있다.

1. **Incoming request**  
2. **Middleware**
    - Globally bound middleware
    - Module bound middleware
3. **Guards**
    - Global guards
    - Controller guards
    - Route guards
4. **Interceptors**(_pre-controller_)
   - Global interceptors
   - Controller interceptors
   - Route interceptors
5. **Pipes**
    - Global pipes
    - Controller pipes
    - Route pipes
    - Route parameter pipes
6. **Controller**(_method handler_)
7. **Service**(_if exists_)
8. **Interceptors**(_post-request_)
   - Route interceptor
   - Controller interceptor
   - Global interceptor
9. **Exception filters**
    - route
    - controller
    - global
10. **Server response**


